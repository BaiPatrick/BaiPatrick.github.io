<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>OpenGL学习</title>
    <url>/undefined/8e2a.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>今天继续学习OpenGL，昨天学习了在vs和vscode中配置OpenGL环境，今天开始学习一些基础的函数</p>
<h2 id="一、窗口"><a href="#一、窗口" class="headerlink" title="一、窗口"></a>一、窗口</h2><h3 id="实例化GLFW窗口"><a href="#实例化GLFW窗口" class="headerlink" title="实例化GLFW窗口"></a>实例化GLFW窗口</h3><ol>
<li>调用<code>glfwinit</code>函数初始化GLFW</li>
<li>使用<code>glfwwindowhint</code>函数配置GLFW<ol>
<li>第一个参数代表选项名称</li>
<li>第二个参数代表接受一个整型，用来设置这个选项的值</li>
</ol>
</li>
<li><code>glfwcreatewindow</code>函数<ol>
<li>前两个参数为窗口的宽和高</li>
<li>第三个参数为窗口的名称（标题）</li>
<li>返回一个glfwwindow对象</li>
</ol>
</li>
<li>GLAD<ol>
<li>管理OpenGL的函数指针，调用OpenGL函数之前需要初始化GLAD</li>
</ol>
</li>
<li>视口（viewport）<ol>
<li>调用<code>glviewport</code>函数设置窗口的维度<ol>
<li>前两个参数控制窗口左下角的位置</li>
<li>第三个和第四个参数控制渲染窗口的宽度和高度（像素）</li>
</ol>
</li>
<li>因为用户改变窗口的大小时，视口也应该被调整，所以对窗口注册一个回调函数，会在每次窗口大小被调整的时候被调用<ol>
<li>函数原型：<code>void framebuffer_size_callback(GLFWwindow* window, int width, int height);</code><ol>
<li><code>glfwwindow</code>作为第一个参数，两个整数代表窗口的新维度</li>
<li>每当窗口改变大小，GLFW会调用这个函数并填充相应的参数</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>渲染循环<ol>
<li>在程序中添加一个while循环，在GLFW退出前一直保持运行</li>
<li>相关函数<ol>
<li><code>GlfwWindowShouldClose</code>:每次循环的开始前检查一次GLFW是否要求退出，如果是函数返回并结束渲染循环</li>
<li><code>GlfwPollEvents</code>:检查有没有触发什么时间、更新窗口状态，并调用对应的回调函数</li>
<li><code>GlfwSwapBuffers</code>:交换颜色缓冲，并且会作为输出显示在屏幕上</li>
</ol>
</li>
</ol>
</li>
<li>结束<ol>
<li>调用<code>glfwterminate</code>函数释放&#x2F;删除之前的分配的所有资源</li>
</ol>
</li>
<li>输入<ol>
<li><code>glfwgetkey</code>函数：<ol>
<li>需要一个窗口以及一个按键作为输入</li>
<li>返回这个按键是否正在被按下</li>
</ol>
</li>
</ol>
</li>
<li>渲染<ol>
<li>所有的渲染操作都放在渲染循环中，每次渲染循环迭代的时候都能被执行</li>
<li>清空屏幕颜色缓冲<ol>
<li>调用<code>glclear</code>函数</li>
<li>接受一个缓冲位来指定要清空的缓冲</li>
</ol>
</li>
<li>设置清空屏幕所用颜色<ol>
<li>调用<code>glclearcolor</code>函数</li>
<li>清除颜色缓冲之后，整个颜色缓冲都会被填充为此函数里所设置的颜色</li>
</ol>
</li>
</ol>
</li>
</ol>
<p>​<span id="more"></span></p>
<h2 id="二、三角形"><a href="#二、三角形" class="headerlink" title="二、三角形"></a>二、三角形</h2><h3 id="1-顶点数组对象-：vertex-array-object，VAO"><a href="#1-顶点数组对象-：vertex-array-object，VAO" class="headerlink" title="1.顶点数组对象 ：vertex array object，VAO"></a>1.顶点数组对象 ：vertex array object，VAO</h3><h3 id="2-顶点缓冲对象：vertex-buffer-object，VBO"><a href="#2-顶点缓冲对象：vertex-buffer-object，VBO" class="headerlink" title="2.顶点缓冲对象：vertex buffer object，VBO"></a>2.顶点缓冲对象：vertex buffer object，VBO</h3><h3 id="3-元素缓冲对象：element-buffer-object，EBO-x2F-索引缓冲对象：index-buffer-object，IBO"><a href="#3-元素缓冲对象：element-buffer-object，EBO-x2F-索引缓冲对象：index-buffer-object，IBO" class="headerlink" title="3.元素缓冲对象：element buffer object，EBO&#x2F;索引缓冲对象：index buffer object，IBO"></a>3.元素缓冲对象：element buffer object，EBO&#x2F;索引缓冲对象：index buffer object，IBO</h3><ol>
<li><p>图形渲染管线</p>
<ol>
<li>3D坐标转为2D坐标的处理过程</li>
<li>指一堆原始图形数据途径一个输送管道，期间经过各种变化处理最终出现在屏幕的过程</li>
<li>主要部分<ol>
<li>把3D坐标转换为2D坐标</li>
<li>把2D坐标转变为实际的有颜色的像素</li>
</ol>
</li>
<li>被划分为几个阶段，每个阶段会把前一个阶段的输出作为输入<ol>
<li>每个阶段都是高度专门化（有一个特定的函数）</li>
<li>很容易并行执行</li>
</ol>
</li>
<li>着色器<ol>
<li>在GPU上为每个阶段运行的小程序</li>
<li>在GPU上运行，节省了CPU时间</li>
<li>着色器语言<ol>
<li>GLSL</li>
<li>HLSL</li>
<li>CG</li>
</ol>
</li>
</ol>
</li>
<li>图形管线分部<ol>
<li>顶点数据<ol>
<li>一系列顶点的集合</li>
<li>一个顶点是一个3D坐标的数据的集合</li>
<li>顶点数据用顶点属性表示，包含任何我们想用的数据</li>
</ol>
</li>
<li>第一部分：顶点着色器<ol>
<li>把一个单独的定点作为输出</li>
<li>主要目的：把3D坐标转为另一种3D坐标，同时允许对顶点属性进行一些基本处理</li>
<li>图元装配<ol>
<li>此阶段将顶点着色器输出的所有顶点作为输入</li>
<li>所有的点装配成指定图元的形状</li>
</ol>
</li>
<li>几何着色器<ol>
<li>接收图元装配的输出</li>
<li>把图元形式的一系列顶点的集合作为输入，可以通过产生新顶点构造出新的图元来生成其他形状</li>
</ol>
</li>
<li>光栅化阶段<ol>
<li>接收几何着色器的输出</li>
<li>把图元映射为最终屏幕上相应的像素，生成供片段着色器使用的片段</li>
<li>片段着色器运行之前会执行裁切：丢弃超出视图以外的所有像素，提升执行效率</li>
</ol>
</li>
<li>片段着色器<ol>
<li>目的：计算一个像素的最终颜色，是所有OpenGL高级效果产生的地方</li>
<li>通常包含3D场景的数据：光照、阴影、光的颜色等</li>
</ol>
</li>
<li>alpha测试和混合阶段<ol>
<li>检测片段的对应的深度，判断像素是其他物体的前面还是后面，决定是否应该丢弃</li>
<li>会检查alpha值(定义了一个物体的透明度)，并对物体进行混合</li>
</ol>
</li>
<li>我们必须定义至少一个顶点着色器和一个片段着色器</li>
</ol>
</li>
<li>顶点输入<ol>
<li>OpenGL仅当3D坐标在3个轴（x、y、z）上-1.0到1.0的范围内才处理它</li>
<li>标准化设备坐标<ol>
<li>所有在能够处理的范围内的坐标</li>
<li>此范围内的坐标最终显示在屏幕上</li>
</ol>
</li>
<li>顶点缓冲对象<ol>
<li>在GPU内存中储存大量顶点</li>
<li>可以一次性发送一大批数据到显卡上，而不是每个顶点发送一次</li>
<li>是OpenGL对象，有一个独一无二的ID</li>
<li>使用<code>glgenbuffers</code>函数和一个缓冲ID生成一个VBO对象</li>
<li>缓冲类型：<code>GL_ARRAY_BUFFER</code></li>
<li>OpenGL允许我们同时绑定多个缓冲，只要是不同的换成类型都可以绑定到目标上</li>
<li>调用<code>glbufferdata</code>函数<ol>
<li>把之前定义的顶点数据复制到缓冲的内存中</li>
<li>专门用来把用户定义的数据复制到当前绑定缓冲的函数</li>
<li>第一个参数：目标缓冲的类型</li>
<li>第二个参数：指定传输数据的大小（以字节为单位）</li>
<li>第三个参数：希望发送的实际数据</li>
<li>第四个参数：指定了我们希望显卡如何管理给定的数据<ol>
<li>GL_STATIC_DRAW：数据不会或几乎不会改变</li>
<li>GL_DYNAMIC_DRAW：数据会被改变很多</li>
<li>GL_STREAM_DRAW：数据每次绘制时都会改变</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>顶点着色器<ol>
<li>可编程着色器其中之一</li>
<li>做渲染的话，OpenGL需要我们至少设置一个顶点和一个片段着色器</li>
<li>向量<ol>
<li>表达了任意空间中的位置和方向，有非常有用的数学属性</li>
<li>GLSL中一个向量有最多4个分量，每个分量值都代表空间中的一个坐标</li>
<li>通过vec.x vec.y vec.z vec.w获取：vec.w用在透视除法上</li>
</ol>
</li>
</ol>
</li>
<li>编译着色器<ol>
<li>创建着色器对象，用ID来引用</li>
<li>用<code>glcreateshader</code>创建着色器</li>
<li>把创建的着色器类型以参数形式提供给<code>glcreateshader</code></li>
<li><code>glcreateshader</code>函数<ol>
<li>第一个参数：要编译的着色器对象</li>
<li>第二个参数：指定了传递的源码字符串数量</li>
<li>第三个参数：顶点着色器真正的源码</li>
<li>第四个参数</li>
</ol>
</li>
<li>检测<ol>
<li><code>glgetshaderiv</code>函数检测是否编译成功</li>
<li><code>glgetshaderinfolog</code>函数获取错误信息，然后打印它</li>
</ol>
</li>
</ol>
</li>
<li>片段着色器<ol>
<li>计算像素最后的颜色输出</li>
<li>只需要一个输出变量，是一个4分量向量，表示最终的输出颜色</li>
<li>声明输出变量可以使用out关键字</li>
<li>使用<code>GL_FRAGMENT_SHADER</code>常量作为着色器类型</li>
</ol>
</li>
<li>着色器程序<ol>
<li>多个着色器合并之后并最终链接完成的版本</li>
<li>链接着色器至一个程序的时候，会把每个着色器的输出链接到下个着色器的输入</li>
<li><code>glcreateprogram</code>函数创建一个程序，并返回新创建程序对象的ID引用</li>
<li><code>gllinkprogram</code>链接编译器</li>
<li>调用<code>gluseprogram</code>函数，用光创建的的程序对象作为它的参数，激活这个程序对象</li>
</ol>
</li>
<li>链接顶点属性<ol>
<li>使用<code>glvertexattribpointer</code>函数告诉OpenGL该如何解析顶点数据<ol>
<li>第一个参数：指定我们要配置的顶点属性</li>
<li>第二个参数：指定顶点属性的大小</li>
<li>第三个参数：指定数据的类型</li>
<li>第四个参数：定义我们是否希望数据被标准化<ol>
<li>设置为：GL_TRUE，所有数据都会被映射到0到1之间</li>
</ol>
</li>
<li>第五个参数：步长<ol>
<li>在连接的顶点属性组之间的间隔</li>
</ol>
</li>
<li>第六个参数：void*<ol>
<li>需要进行强制类型转换</li>
<li>表示位置数据在缓冲中起始位置的偏移量</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>今天学习了如何初始化窗口，了解了图形渲染管线的一些基础知识和相关函数</p>
<p>暂时学习到顶点数组对象，找到工作后继续学习</p>
<p>学习网站：<a href="https://learnopengl-cn.github.io/">https://learnopengl-cn.github.io/</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>图形学</category>
      </categories>
      <tags>
        <tag>图形学</tag>
        <tag>OpenGL - 渲染</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenGL</title>
    <url>/undefined/22236.html</url>
    <content><![CDATA[<h2 id="一、什么是OpenGL"><a href="#一、什么是OpenGL" class="headerlink" title="一、什么是OpenGL"></a>一、什么是OpenGL</h2><ol>
<li>OpenGL是一种图形接口，是跨平台的API</li>
<li>允许我们访问GPU，也就是显卡，图像处理单元</li>
<li>允许访问和操作GPU的许多接口中的一种，其他接口比如：Direct3D、Vulcan、Metal等等</li>
<li>一定程度上允许我们控制显卡</li>
<li>关于一些对OpenGL的误解<ol>
<li>不是一个类库，因为本身没有代码</li>
<li>OpenGL核心本身是一种规范，类似于C++规范</li>
<li>没有确定任何代码和类似的事情</li>
<li>只是一种能利用这种API做什么的规范，没有任何具体的实现</li>
</ol>
</li>
<li>如何调用OpenGL<ol>
<li>使用显卡不同，对OpenGL调用不同</li>
</ol>
</li>
<li>传统OpenGL和现代OpenGL的区别<ol>
<li>现代OpenGL更像一个循环，一个低级的法则，能给更多的控制权</li>
<li>最大的区别：着色器<ol>
<li>着色器：程序，在GPU上运行的代码</li>
</ol>
</li>
</ol>
</li>
</ol>
<p>​<span id="more"></span></p>
<h2 id="二、OpenGL"><a href="#二、OpenGL" class="headerlink" title="二、OpenGL"></a>二、OpenGL</h2><h3 id="1-OpenGL"><a href="#1-OpenGL" class="headerlink" title="1.OpenGL"></a>1.OpenGL</h3><ol>
<li><p>对扩展的支持，当显卡公司提出一个新特性或者渲染上的大优化，通常会以扩展的方式在驱动中实现</p>
</li>
<li><p>使用扩展的代码大多如下：</p>
<p>if(GL_ARB_extension_name)</p>
<p> {</p>
<p>  &#x2F;&#x2F; 使用硬件支持的全新的现代特性</p>
<p> }</p>
<p>else</p>
<p> { </p>
<p>   &#x2F;&#x2F; 不支持此扩展: 用旧的方式去做</p>
<p> }</p>
</li>
<li><p>状态机：本质上是个大状态机</p>
<ol>
<li>OpenGL上下文：<ol>
<li>OpenGL的状态</li>
<li>更改OpenGL状态：设置选项，操作缓冲</li>
<li>使用当前的OpenGL上下文进行渲染</li>
</ol>
</li>
<li>状态设置函数：<ol>
<li>改变上下文</li>
</ol>
</li>
<li>状态使用函数：<ol>
<li>根据当前OpenGL的状态进行一些操作</li>
</ol>
</li>
</ol>
</li>
<li><p>对象</p>
<ol>
<li><p>一些选项的集合，代表OpenGL状态的一个子集</p>
</li>
<li><p>当我们使用一个对象时，通常看起来像如下一样</p>
<p>&#x2F;&#x2F; OpenGL的状态 </p>
<p>struct OpenGL_Context {   </p>
<p> …    </p>
<p>object* object_Window_Target;</p>
<p> … </p>
<p> };</p>
</li>
<li><p>使用OpenGL常见工作流</p>
<p>&#x2F;&#x2F; 创建对象 </p>
<p>unsigned int objectId &#x3D; 0; </p>
<p>glGenObject(1, &amp;objectId); </p>
<p>&#x2F;&#x2F; 绑定对象至上下文 </p>
<p>glBindObject(GL_WINDOW_TARGET, objectId);</p>
<p> &#x2F;&#x2F; 设置当前绑定到 GL_WINDOW_TARGET 的对象的一些选项</p>
<p> glSetObjectOption(GL_WINDOW_TARGET, GL_OPTION_WINDOW_WIDTH, 800); </p>
<p>glSetObjectOption(GL_WINDOW_TARGET, GL_OPTION_WINDOW_HEIGHT, 600); </p>
<p>&#x2F;&#x2F; 将上下文对象设回默认 </p>
<p>glBindObject(GL_WINDOW_TARGET, 0);</p>
</li>
<li><p>使用对象的好处</p>
<ol>
<li>在程序中不止可以定义一个对象，并设置它们的选项，每个对象都可以是不同的设置</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="2-visual-studio配置GLFW和GLAD"><a href="#2-visual-studio配置GLFW和GLAD" class="headerlink" title="2.visual studio配置GLFW和GLAD"></a>2.visual studio配置GLFW和GLAD</h3><ol>
<li>GLFW<ol>
<li>使用Cmake进行编译<ol>
<li>选择源代码目录和存放编译结果的目标文件目录<ol>
<li>源代码目录：GLFW的源代码根目录</li>
<li>目标文件目录：新建build文件夹</li>
</ol>
</li>
</ol>
</li>
<li>编译<ol>
<li>build文件夹中选择GLFW.sln文件，选择生成</li>
<li>build&#x2F;src&#x2F;Debug中出现编译的库文件glfw3.lib</li>
<li>指定IDE库和头文件位置<ol>
<li>新建文件夹</li>
<li>在新建文件夹中创建libs和include文件夹</li>
<li>将glfw文件夹中include文件夹中的glfw复制进新建的include中</li>
<li>将build\src\Debug中glfw3.lib放入libs文件夹中</li>
</ol>
</li>
</ol>
</li>
<li>链接<ol>
<li>vc++目录<ol>
<li>包含目录：新建文件夹\include</li>
<li>库目录：新建文件夹\libs</li>
</ol>
</li>
<li>链接器<ol>
<li>输入：添加opengl32.lib和glfw.lib依赖项</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>GLAD<ol>
<li>开源的库，可以简化调用函数过程</li>
<li>打开GLAD在线服务，选择相应信息，生成库文件</li>
<li>将两个头文件(glad和KHR)复制进新建文件夹\include中</li>
<li>将glad.c添加到工程中</li>
<li>GLAD需要置于在其他依赖与OpenGL的头文件(如GLFW)之前</li>
</ol>
</li>
</ol>
<h3 id="3-visual-studio-code配置GLFW"><a href="#3-visual-studio-code配置GLFW" class="headerlink" title="3.visual studio code配置GLFW"></a>3.visual studio code配置GLFW</h3><ol>
<li><p>主要步骤分为：</p>
<ol>
<li>配置编译环境</li>
<li>配置OpenGL环境</li>
</ol>
</li>
<li><p>OpenGL环境配置</p>
<ol>
<li><p>安装MinGW</p>
<ol>
<li>从官网下载MinGW，不要下载MinGW-w64，因为后面可能会出现问题</li>
<li>将下载完成的压缩包解压到指定目录</li>
<li>将MinGW文件下的bin文件添加到系统环境变量中</li>
</ol>
</li>
<li><p>验证编译器环境</p>
<ol>
<li>按键<code>ctrl+shift+p</code>，输入 <code>create C++ project</code> 创建一个C++文件工程</li>
<li>打开终端（快捷键F5），输入 <code>make run</code>命令，开始编译运行</li>
</ol>
</li>
<li><p>配置OpenGL环境</p>
<ol>
<li><p>下载GLFW，下载地址为：<a href="https://www.glfw.org/download.html">https://www.glfw.org/download.html</a></p>
<ol>
<li>安装32位</li>
<li>将解压包中<code>D:\Download\glfw-3.3.8.bin.WIN32\include</code>下的GLFW文件，复制到vscode创建的C++工程下的include文件夹下</li>
<li>将解压包中<code>D:\Download\glfw-3.3.8.bin.WIN32\lib-mingw</code>路径下的<code>libglfw3.a</code>、<code>libglfw3dll.a</code>两个文件，复制到vscode创建的C++工程下的lib文件夹下</li>
<li>将解压包中<code>D:\Download\glfw-3.3.8.bin.WIN32\lib-mingw</code>路径下的<code>glfw3.dll</code>文件，复制到vscode创建的C++工程下的output文件夹下</li>
</ol>
</li>
<li><p>glad配置</p>
<ol>
<li><p>glad生成静态库的地址为：<a href="https://glad.dav1d.de/">https://glad.dav1d.de/</a></p>
</li>
<li><p>下载生成结果</p>
</li>
<li><p>在解压目录中使用cmd</p>
</li>
<li><p>执行命令：</p>
<p><code> gcc ./src/glad.c -c -I ./include/ // 生成 .o文件</code><br><code> ar -rc libglad.a glad.o           // 生成我们所需要的 .a文件</code></p>
<p>此时在glad文件路径下生成<code>glad.o</code>和<code>libglad.a</code>文件</p>
</li>
<li><p>将<code>glad\include</code>路径下的两个文件夹复制到vscode创建的C++工程下的include文件夹下</p>
</li>
<li><p>将<code>glad</code>路径下生成的<code>libglad.a</code>文件复制到vscode创建的C++工程下的lib文件夹下</p>
</li>
</ol>
</li>
<li><p>修改Makefile文件</p>
<ol>
<li>添加：<code>LIBRARIES	:= -lglad -lglfw3dll    # add</code></li>
<li>在此语句<code>$(MAIN): $(OBJECTS)  $(CXX) $(CXXFLAGS) $(INCLUDES) -o $(OUTPUTMAIN) $(OBJECTS) $(LFLAGS) $(LIBS) $(LIBRARIES)</code>最后添加： <code>$(LIBRARIES)</code></li>
</ol>
</li>
</ol>
</li>
<li><p>添加源文件</p>
<ol>
<li><p>在<code>main.cpp</code>文件中添加如下代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;glad/glad.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GLFW/glfw3.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">framebuffer_size_callback</span><span class="params">(GLFWwindow* window, <span class="type">int</span> width, <span class="type">int</span> height)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">processInput</span><span class="params">(GLFWwindow *window)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// settings</span></span><br><span class="line"><span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> SCR_WIDTH = <span class="number">800</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> SCR_HEIGHT = <span class="number">600</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// glfw: initialize and configure</span></span><br><span class="line">    <span class="comment">// ------------------------------</span></span><br><span class="line">    <span class="built_in">glfwInit</span>();</span><br><span class="line">    <span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MAJOR, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MINOR, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">glfwWindowHint</span>(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __APPLE__</span></span><br><span class="line">    <span class="built_in">glfwWindowHint</span>(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// glfw window creation</span></span><br><span class="line">    <span class="comment">// --------------------</span></span><br><span class="line">    GLFWwindow* window = <span class="built_in">glfwCreateWindow</span>(SCR_WIDTH, SCR_HEIGHT, <span class="string">&quot;LearnOpenGL&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (window == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Failed to create GLFW window&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">glfwTerminate</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">glfwMakeContextCurrent</span>(window);</span><br><span class="line">    <span class="built_in">glfwSetFramebufferSizeCallback</span>(window, framebuffer_size_callback);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// glad: load all OpenGL function pointers</span></span><br><span class="line">    <span class="comment">// ---------------------------------------</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">gladLoadGLLoader</span>((GLADloadproc)glfwGetProcAddress))</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Failed to initialize GLAD&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line">    <span class="comment">// render loop</span></span><br><span class="line">    <span class="comment">// -----------</span></span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">glfwWindowShouldClose</span>(window))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// input</span></span><br><span class="line">        <span class="comment">// -----</span></span><br><span class="line">        <span class="built_in">processInput</span>(window);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// render</span></span><br><span class="line">        <span class="comment">// ------</span></span><br><span class="line">        <span class="built_in">glClearColor</span>(<span class="number">0.2f</span>, <span class="number">0.3f</span>, <span class="number">0.3f</span>, <span class="number">1.0f</span>);</span><br><span class="line">        <span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// glfw: swap buffers and poll IO events (keys pressed/released, mouse moved etc.)</span></span><br><span class="line">        <span class="comment">// -------------------------------------------------------------------------------</span></span><br><span class="line">        <span class="built_in">glfwSwapBuffers</span>(window);</span><br><span class="line">        <span class="built_in">glfwPollEvents</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// glfw: terminate, clearing all previously allocated GLFW resources.</span></span><br><span class="line">    <span class="comment">// ------------------------------------------------------------------</span></span><br><span class="line">    <span class="built_in">glfwTerminate</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// process all input: query GLFW whether relevant keys are pressed/released this frame and react accordingly</span></span><br><span class="line"><span class="comment">// ---------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">processInput</span><span class="params">(GLFWwindow *window)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">glfwGetKey</span>(window, GLFW_KEY_ESCAPE) == GLFW_PRESS)</span><br><span class="line">        <span class="built_in">glfwSetWindowShouldClose</span>(window, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// glfw: whenever the window size changed (by OS or user resize) this callback function executes</span></span><br><span class="line"><span class="comment">// ---------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">framebuffer_size_callback</span><span class="params">(GLFWwindow* window, <span class="type">int</span> width, <span class="type">int</span> height)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// make sure the viewport matches the new window dimensions; note that width and </span></span><br><span class="line">    <span class="comment">// height will be significantly larger than specified on retina displays.</span></span><br><span class="line">    <span class="built_in">glViewport</span>(<span class="number">0</span>, <span class="number">0</span>, width, height);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>测试</p>
<ol>
<li>在vscode打开终端，执行<code>make run</code>进行测试</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这次对OpenGL进行了详细的环境配置，包括在visual studio的配置以及在visual studio code中的配置，其中visual studio有官方文档可以进行学习操作，官方文档对配置环境描述很详细。在vscode配置中遇到一些问题：</p>
<ol>
<li>glfw版本选择错误，导致最后测试时发生错误，glfw版本选择时应该选择32位，选择64位会出现错误</li>
<li>其余问题都为操作失误，没有理解上的错误</li>
</ol>
]]></content>
      <categories>
        <category>图形学</category>
      </categories>
      <tags>
        <tag>图形学</tag>
        <tag>OpenGL</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenGL_渲染管线</title>
    <url>/undefined/3f56.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>今天继续学习OpenGL，昨天学习了在vs和vscode中配置OpenGL环境，今天开始学习一些基础的函数</p>
<h2 id="一、窗口"><a href="#一、窗口" class="headerlink" title="一、窗口"></a>一、窗口</h2><h3 id="实例化GLFW窗口"><a href="#实例化GLFW窗口" class="headerlink" title="实例化GLFW窗口"></a>实例化GLFW窗口</h3><ol>
<li>调用<code>glfwinit</code>函数初始化GLFW</li>
<li>使用<code>glfwwindowhint</code>函数配置GLFW<ol>
<li>第一个参数代表选项名称</li>
<li>第二个参数代表接受一个整型，用来设置这个选项的值</li>
</ol>
</li>
<li><code>glfwcreatewindow</code>函数<ol>
<li>前两个参数为窗口的宽和高</li>
<li>第三个参数为窗口的名称（标题）</li>
<li>返回一个glfwwindow对象</li>
</ol>
</li>
<li>GLAD<ol>
<li>管理OpenGL的函数指针，调用OpenGL函数之前需要初始化GLAD</li>
</ol>
</li>
<li>视口（viewport）<ol>
<li>调用<code>glviewport</code>函数设置窗口的维度<ol>
<li>前两个参数控制窗口左下角的位置</li>
<li>第三个和第四个参数控制渲染窗口的宽度和高度（像素）</li>
</ol>
</li>
<li>因为用户改变窗口的大小时，视口也应该被调整，所以对窗口注册一个回调函数，会在每次窗口大小被调整的时候被调用<ol>
<li>函数原型：<code>void framebuffer_size_callback(GLFWwindow* window, int width, int height);</code><ol>
<li><code>glfwwindow</code>作为第一个参数，两个整数代表窗口的新维度</li>
<li>每当窗口改变大小，GLFW会调用这个函数并填充相应的参数</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>渲染循环<ol>
<li>在程序中添加一个while循环，在GLFW退出前一直保持运行</li>
<li>相关函数<ol>
<li><code>GlfwWindowShouldClose</code>:每次循环的开始前检查一次GLFW是否要求退出，如果是函数返回并结束渲染循环</li>
<li><code>GlfwPollEvents</code>:检查有没有触发什么时间、更新窗口状态，并调用对应的回调函数</li>
<li><code>GlfwSwapBuffers</code>:交换颜色缓冲，并且会作为输出显示在屏幕上</li>
</ol>
</li>
</ol>
</li>
<li>结束<ol>
<li>调用<code>glfwterminate</code>函数释放&#x2F;删除之前的分配的所有资源</li>
</ol>
</li>
<li>输入<ol>
<li><code>glfwgetkey</code>函数：<ol>
<li>需要一个窗口以及一个按键作为输入</li>
<li>返回这个按键是否正在被按下</li>
</ol>
</li>
</ol>
</li>
<li>渲染<ol>
<li>所有的渲染操作都放在渲染循环中，每次渲染循环迭代的时候都能被执行</li>
<li>清空屏幕颜色缓冲<ol>
<li>调用<code>glclear</code>函数</li>
<li>接受一个缓冲位来指定要清空的缓冲</li>
</ol>
</li>
<li>设置清空屏幕所用颜色<ol>
<li>调用<code>glclearcolor</code>函数</li>
<li>清除颜色缓冲之后，整个颜色缓冲都会被填充为此函数里所设置的颜色</li>
</ol>
</li>
</ol>
</li>
</ol>
<p>​<span id="more"></span></p>
<h2 id="二、三角形"><a href="#二、三角形" class="headerlink" title="二、三角形"></a>二、三角形</h2><h3 id="1-顶点数组对象-：vertex-array-object，VAO"><a href="#1-顶点数组对象-：vertex-array-object，VAO" class="headerlink" title="1.顶点数组对象 ：vertex array object，VAO"></a>1.顶点数组对象 ：vertex array object，VAO</h3><h3 id="2-顶点缓冲对象：vertex-buffer-object，VBO"><a href="#2-顶点缓冲对象：vertex-buffer-object，VBO" class="headerlink" title="2.顶点缓冲对象：vertex buffer object，VBO"></a>2.顶点缓冲对象：vertex buffer object，VBO</h3><h3 id="3-元素缓冲对象：element-buffer-object，EBO-x2F-索引缓冲对象：index-buffer-object，IBO"><a href="#3-元素缓冲对象：element-buffer-object，EBO-x2F-索引缓冲对象：index-buffer-object，IBO" class="headerlink" title="3.元素缓冲对象：element buffer object，EBO&#x2F;索引缓冲对象：index buffer object，IBO"></a>3.元素缓冲对象：element buffer object，EBO&#x2F;索引缓冲对象：index buffer object，IBO</h3><ol>
<li><p>图形渲染管线</p>
<ol>
<li>3D坐标转为2D坐标的处理过程</li>
<li>指一堆原始图形数据途径一个输送管道，期间经过各种变化处理最终出现在屏幕的过程</li>
<li>主要部分<ol>
<li>把3D坐标转换为2D坐标</li>
<li>把2D坐标转变为实际的有颜色的像素</li>
</ol>
</li>
<li>被划分为几个阶段，每个阶段会把前一个阶段的输出作为输入<ol>
<li>每个阶段都是高度专门化（有一个特定的函数）</li>
<li>很容易并行执行</li>
</ol>
</li>
<li>着色器<ol>
<li>在GPU上为每个阶段运行的小程序</li>
<li>在GPU上运行，节省了CPU时间</li>
<li>着色器语言<ol>
<li>GLSL</li>
<li>HLSL</li>
<li>CG</li>
</ol>
</li>
</ol>
</li>
<li>图形管线分部<ol>
<li>顶点数据<ol>
<li>一系列顶点的集合</li>
<li>一个顶点是一个3D坐标的数据的集合</li>
<li>顶点数据用顶点属性表示，包含任何我们想用的数据</li>
</ol>
</li>
<li>第一部分：顶点着色器<ol>
<li>把一个单独的定点作为输出</li>
<li>主要目的：把3D坐标转为另一种3D坐标，同时允许对顶点属性进行一些基本处理</li>
<li>图元装配<ol>
<li>此阶段将顶点着色器输出的所有顶点作为输入</li>
<li>所有的点装配成指定图元的形状</li>
</ol>
</li>
<li>几何着色器<ol>
<li>接收图元装配的输出</li>
<li>把图元形式的一系列顶点的集合作为输入，可以通过产生新顶点构造出新的图元来生成其他形状</li>
</ol>
</li>
<li>光栅化阶段<ol>
<li>接收几何着色器的输出</li>
<li>把图元映射为最终屏幕上相应的像素，生成供片段着色器使用的片段</li>
<li>片段着色器运行之前会执行裁切：丢弃超出视图以外的所有像素，提升执行效率</li>
</ol>
</li>
<li>片段着色器<ol>
<li>目的：计算一个像素的最终颜色，是所有OpenGL高级效果产生的地方</li>
<li>通常包含3D场景的数据：光照、阴影、光的颜色等</li>
</ol>
</li>
<li>alpha测试和混合阶段<ol>
<li>检测片段的对应的深度，判断像素是其他物体的前面还是后面，决定是否应该丢弃</li>
<li>会检查alpha值(定义了一个物体的透明度)，并对物体进行混合</li>
</ol>
</li>
<li>我们必须定义至少一个顶点着色器和一个片段着色器</li>
</ol>
</li>
<li>顶点输入<ol>
<li>OpenGL仅当3D坐标在3个轴（x、y、z）上-1.0到1.0的范围内才处理它</li>
<li>标准化设备坐标<ol>
<li>所有在能够处理的范围内的坐标</li>
<li>此范围内的坐标最终显示在屏幕上</li>
</ol>
</li>
<li>顶点缓冲对象<ol>
<li>在GPU内存中储存大量顶点</li>
<li>可以一次性发送一大批数据到显卡上，而不是每个顶点发送一次</li>
<li>是OpenGL对象，有一个独一无二的ID</li>
<li>使用<code>glgenbuffers</code>函数和一个缓冲ID生成一个VBO对象</li>
<li>缓冲类型：<code>GL_ARRAY_BUFFER</code></li>
<li>OpenGL允许我们同时绑定多个缓冲，只要是不同的换成类型都可以绑定到目标上</li>
<li>调用<code>glbufferdata</code>函数<ol>
<li>把之前定义的顶点数据复制到缓冲的内存中</li>
<li>专门用来把用户定义的数据复制到当前绑定缓冲的函数</li>
<li>第一个参数：目标缓冲的类型</li>
<li>第二个参数：指定传输数据的大小（以字节为单位）</li>
<li>第三个参数：希望发送的实际数据</li>
<li>第四个参数：指定了我们希望显卡如何管理给定的数据<ol>
<li>GL_STATIC_DRAW：数据不会或几乎不会改变</li>
<li>GL_DYNAMIC_DRAW：数据会被改变很多</li>
<li>GL_STREAM_DRAW：数据每次绘制时都会改变</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>顶点着色器<ol>
<li>可编程着色器其中之一</li>
<li>做渲染的话，OpenGL需要我们至少设置一个顶点和一个片段着色器</li>
<li>向量<ol>
<li>表达了任意空间中的位置和方向，有非常有用的数学属性</li>
<li>GLSL中一个向量有最多4个分量，每个分量值都代表空间中的一个坐标</li>
<li>通过vec.x vec.y vec.z vec.w获取：vec.w用在透视除法上</li>
</ol>
</li>
</ol>
</li>
<li>编译着色器<ol>
<li>创建着色器对象，用ID来引用</li>
<li>用<code>glcreateshader</code>创建着色器</li>
<li>把创建的着色器类型以参数形式提供给<code>glcreateshader</code></li>
<li><code>glcreateshader</code>函数<ol>
<li>第一个参数：要编译的着色器对象</li>
<li>第二个参数：指定了传递的源码字符串数量</li>
<li>第三个参数：顶点着色器真正的源码</li>
<li>第四个参数</li>
</ol>
</li>
<li>检测<ol>
<li><code>glgetshaderiv</code>函数检测是否编译成功</li>
<li><code>glgetshaderinfolog</code>函数获取错误信息，然后打印它</li>
</ol>
</li>
</ol>
</li>
<li>片段着色器<ol>
<li>计算像素最后的颜色输出</li>
<li>只需要一个输出变量，是一个4分量向量，表示最终的输出颜色</li>
<li>声明输出变量可以使用out关键字</li>
<li>使用<code>GL_FRAGMENT_SHADER</code>常量作为着色器类型</li>
</ol>
</li>
<li>着色器程序<ol>
<li>多个着色器合并之后并最终链接完成的版本</li>
<li>链接着色器至一个程序的时候，会把每个着色器的输出链接到下个着色器的输入</li>
<li><code>glcreateprogram</code>函数创建一个程序，并返回新创建程序对象的ID引用</li>
<li><code>gllinkprogram</code>链接编译器</li>
<li>调用<code>gluseprogram</code>函数，用光创建的的程序对象作为它的参数，激活这个程序对象</li>
</ol>
</li>
<li>链接顶点属性<ol>
<li>使用<code>glvertexattribpointer</code>函数告诉OpenGL该如何解析顶点数据<ol>
<li>第一个参数：指定我们要配置的顶点属性</li>
<li>第二个参数：指定顶点属性的大小</li>
<li>第三个参数：指定数据的类型</li>
<li>第四个参数：定义我们是否希望数据被标准化<ol>
<li>设置为：GL_TRUE，所有数据都会被映射到0到1之间</li>
</ol>
</li>
<li>第五个参数：步长<ol>
<li>在连接的顶点属性组之间的间隔</li>
</ol>
</li>
<li>第六个参数：void*<ol>
<li>需要进行强制类型转换</li>
<li>表示位置数据在缓冲中起始位置的偏移量</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>今天学习了如何初始化窗口，了解了图形渲染管线的一些基础知识和相关函数</p>
<p>暂时学习到顶点数组对象，找到工作后继续学习</p>
<p>学习网站：<a href="https://learnopengl-cn.github.io/">https://learnopengl-cn.github.io/</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>图形学</category>
      </categories>
      <tags>
        <tag>-图形学 -渲染 -OpenGL</tag>
      </tags>
  </entry>
</search>
